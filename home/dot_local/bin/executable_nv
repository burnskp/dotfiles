#!/bin/bash
set -euo pipefail

if command -v gdate > /dev/null 2>&1; then
  DATE="gdate"
else
  DATE="date"
fi

# Configuration
readonly DATA="${XDG_DATA_HOME}/devcontainer"
readonly CONTAINER="ghcr.io/burnskp/dev:latest"

# The image is built by GitHub Actions on:
#   cron: 0 1 * * 0   (Sundays at 01:00)
# We assume the build completes reasonably soon after that time.

usage() {
  cat << EOF
Usage: $(basename "$0") [OPTIONS] [TARGET] [extra args...]

Options:
  -F, --force-pull   Always docker pull the image before running
      --skip-pull    Skip age-based pull check entirely
  -h, --help         Show this help

Behavior:
  * By default, the script:
      - Checks the local image creation time
      - Computes the last scheduled build time
      - If the image is older than the last scheduled build, it tries to pull
        a newer one.
      - If no newer image exists and the image is still older than the last
        scheduled build, it warns and asks you to press Enter to continue.
  * You can override with --force-pull or --skip-pull.
EOF
}

# Compute the epoch time of the most recent scheduled build based on:
#   cron: 0 1 * * 0  (Sunday at 01:00)
get_last_scheduled_build_epoch() {
  local now candidate last
  now=$($DATE +%s)

  # 'this sunday' = upcoming Sunday unless today is Sunday
  candidate=$($DATE -d 'this sunday 01:00' +%s)

  if ((now >= candidate)); then
    # We are past this Sunday's 01:00 → last scheduled build = this Sunday 01:00
    last=$candidate
  else
    # We are before this Sunday's 01:00 → last scheduled build = previous Sunday 01:00
    last=$((candidate - 7 * 24 * 60 * 60))
  fi

  printf '%s\n' "$last"
}

ensure_image_freshness() {
  local force_pull="$1"
  local skip_pull="$2"

  if ! command -v docker > /dev/null 2>&1; then
    echo "Error: docker not found in PATH" >&2
    exit 1
  fi

  # If user explicitly says "don't pull", honor that unless force is set.
  if [[ $skip_pull == "true" && $force_pull == "false" ]]; then
    return
  fi

  # If image doesn't exist locally, just pull it.
  local created_raw image_created_ts last_build_ts before_ts after_ts
  if ! created_raw=$(docker image inspect --format '{{.Created}}' "$CONTAINER" 2> /dev/null); then
    echo "Local image '$CONTAINER' not found. Pulling..." >&2
    docker pull "$CONTAINER"
    return
  fi

  image_created_ts=$($DATE -d "$created_raw" +%s)
  last_build_ts=$(get_last_scheduled_build_epoch)

  if [[ $force_pull == "true" ]]; then
    echo "Forcing docker pull of $CONTAINER..." >&2
    if ! docker pull "$CONTAINER"; then
      echo "Warning: docker pull failed; continuing with existing image." >&2
    fi
    return
  fi

  # If image is newer than or equal to last scheduled build, it's "fresh enough".
  if ((image_created_ts >= last_build_ts)); then
    return
  fi

  # Otherwise try to update it.
  echo "Local image '$CONTAINER' is older than the last scheduled build." >&2
  echo "Attempting to pull a newer image..." >&2

  before_ts="$image_created_ts"

  if ! docker pull "$CONTAINER"; then
    echo "Warning: docker pull failed; continuing with existing image." >&2
  fi

  # Re-check the image creation time after pull.
  created_raw=$(docker image inspect --format '{{.Created}}' "$CONTAINER" 2> /dev/null || true)
  if [[ -n $created_raw ]]; then
    after_ts=$($DATE -d "$created_raw" +%s)
  else
    after_ts="$before_ts"
  fi

  # If it's not newer, warn and require Enter (when interactive).
  if ((after_ts <= before_ts)); then
    local last_build_human image_human
    last_build_human=$($DATE -d "@$last_build_ts")
    image_human=$($DATE -d "@$image_created_ts")

    echo >&2
    echo "WARNING: No newer image for '$CONTAINER' is available." >&2
    echo "         Local image created : $image_human" >&2
    echo "         Last scheduled build: $last_build_human" >&2
    echo >&2

    if [[ -t 0 ]]; then
      echo "Press Enter to continue using this image, or Ctrl+C to abort..." >&2
      read -r _
    else
      echo "Non-interactive session detected; continuing without prompt." >&2
    fi
  fi
}

# Helper function to run docker container with common volumes
run_container() {
  docker run --rm -it \
    --security-opt label=disable \
    --security-opt seccomp=unconfined \
    --cap-add=sys_admin \
    --cap-add mknod \
    --device=/dev/fuse \
    -v "$SSH_AUTH_SOCK:/ssh-agent" \
    -e SSH_AUTH_SOCK=/ssh-agent \
    -v "$HOME/.ssh/config":/home/ubuntu/.ssh/config:ro \
    -v "$HOME/.ssh/pub":/home/ubuntu/.ssh/pub:ro \
    -e TERM \
    -v "$XDG_CONFIG_HOME/git":/home/ubuntu/.config/git:ro \
    -v "$XDG_DATA_HOME/notes":/home/ubuntu/.local/share/notes:rw \
    -v "$DATA:/data" \
    "$@"
}

# Handle file in a git repository
handle_git_file() {
  local target="$1"
  shift

  local git_root
  git_root="$(git -C "$(dirname "$(realpath "$target")")" rev-parse --show-toplevel)"
  local container_dir
  container_dir="/work/$(basename "$git_root")"
  local abs_path
  abs_path="$(realpath "$target")"
  local rel_file="${abs_path#"$git_root"/}"

  run_container \
    -v "$git_root:/$container_dir" \
    "$CONTAINER" \
    "$container_dir" "$@" "/$container_dir/$rel_file"
}

# Handle standalone file (not in git repository)
handle_standalone_file() {
  local target="$1"
  shift
  local filename="${target##*/}"

  run_container \
    -v "$(realpath "$target"):/work/$filename" \
    "$CONTAINER" \
    "/work" "$@" "/work/$filename"
}

# Handle git repository directory
handle_git_dir() {
  local workdir="$1"
  local container_dir
  container_dir="/work/$(basename "$workdir")"
  shift

  run_container \
    -v "$workdir:$container_dir" \
    "$CONTAINER" \
    "$container_dir" \
    "$@"
}

# ---- option parsing ---------------------------------------------------------
force_pull=false
skip_auto_pull=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -F | --force-pull)
      force_pull=true
      shift
      ;;
    --skip-pull | --no-pull)
      skip_auto_pull=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      exit 1
      ;;
    *)
      break
      ;;
  esac
done

# Only now do we touch Docker / image.
ensure_image_freshness "$force_pull" "$skip_auto_pull"

if [[ ${TERMINAL:-} == "ghostty" ]]; then
  TERM=xterm-ghostty
fi

# Main logic
if [ $# -gt 0 ]; then
  target="${!#}"

  # Check if target is in a git repository
  if git -C "$(dirname "$(realpath "$target")")" rev-parse 2> /dev/null; then
    if [ -f "$target" ]; then
      handle_git_file "$@"
    elif [ -d "$target" ]; then
      handle_git_dir "$(git -C "$(realpath "$target")" rev-parse --show-toplevel)"
    else
      echo "Error: target '$target' does not exist" >&2
      exit 1
    fi
  elif [ -f "$target" ]; then
    handle_standalone_file "$@"
  else
    echo "Error: target '$target' is not a valid file or directory" >&2
    exit 1
  fi
elif git -C "$PWD" rev-parse 2> /dev/null; then
  handle_git_dir "$(git -C "$PWD" rev-parse --show-toplevel)"
else
  echo "Error: not in a git repository and no file target specified" >&2
  exit 1
fi
